# 1. 객체 지향 프로그래밍의 특징에 대하여 설명해주세요.

<details>
  <summary>답변</summary>

객체 지향 프로그래밍은 어떤 개념에 대한 자료형과 함수를 ‘객체’로 묶어 관리하는 패러다임이다.

1. 추상화

   객체들이 공통적으로 필요로 하는 속성이나 동작을 하나로 추출해 내는 것

2. 캡슐화

   정보 은닉화를 통해 높은 응집도, 낮은 결합도를 유지할 수 있도록 설계하는 것

   객체 내부가 어떻게 구현되어 있는지를 은닉하여 외부에서 실수로 건드려 손상시키는 일을 방지하는 것이다.

   독립적으로 만들어진 객체 간 의존도를 낮추는 것

   의도하지 않은 오류를 방지하고 유지보수 효율을 높일 수 있다.

3. 상속

   자식 클래스가 부모 클래스의 속성이나 메소드를 그대로 물려받아 사용하거나 다듬어 사용할 수 있게 해주는 것이다.

   자식 클래스를 외부로부터 은닉하는 캡슐화의 일종이다.

4. 다형성

   부모 클래스의 메소드를 자식 클래스가 오버라이딩하여 자신의 역할에 맞게 활용하는 것

   서로 다른 클래스의 객체가 같은 동작을 수행하도록 명령을 받았을 때, 각자의 특성에 맞게 다르게 동작하는 것

   상속과 함께 사용할 때, 코드가 간결해지고 유연해질 수 있다.

[https://velog.io/@haero_kim/객체지향-프로그래밍-이해하기](https://velog.io/@haero_kim/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

</details>

# 2. 일급 객체에 대하여 설명해주세요.

<details>
  <summary>답변</summary>

일급 객체란 다른 객체들에게 일반적으로 적용할 수 있는 연산을 모두 지원하는 객체를 말한다.

비슷한 말로 일급 시민이라는 말이 있는데 이것은 어떤 혜택을 받는다는 것이 아닌 다른 요소들과 아무런 차별이 없다는 것을 뜻한다.

일급 객체는 `변수에 할당될 수 있다`, `다른 함수를 인자로 전달 받는다`, `다른 함수의 반환 값으로 사용될 수 있다`는 특징이 있다.

</details>

# 3. 고차 함수에 대하여 설명해주세요.

<details>
  <summary>답변</summary>

고차 함수는 함수를 인자로 받거나 함수를 리턴하는 함수를 의미한다.

대표적인 예시로 `map`, `filter`, `reduce` 함수가 있다.

좀 더 높은 수준의 추상화가 가능해지기 때문에 중복되는 부분이 줄어들어 가독성이 높아진다.

고차 함수의 인자로 전달되는 함수를 콜백이라고 부른다.

</details>

# 4. 프로세스와 스레드란? 프로세스와 스레드의 차이점

<details>
  <summary>답변</summary>

프로세스란 운영체제로부터 자원을 할당받은 작업의 단위이고 스레드란 프로세스가 할당받은 자원을 이용하는 실행 흐름 단위이다.

파일 형태로 저장 장치에 저장되어있지만 메모리에는 올라가지 않은 정적인 상태를 프로그램이라 하는데, 이 프로그램을 실행하게되면 프로그램이 동적인 상태로 바뀌게 된다. 이것을 프로세스라고 한다.

스레드는 프로세스를 구성하는 더 작은 단위이다.

프로세스는 독립적으로 자원을 할당받기 때문에 다른 프로세스와 자원을 공유하지 않는다. 프로세스의 메모리 영역은 code / heap / data / stack 으로 이루어진다.

반면에 스레드는 서로 메모리를 공유한다. code / heap / data 를 공유한다.

따라서 하나의 프로세스에 오류가 발생했을 경우 다른 프로세스와 공유하고 있는 파일이 있지 않은 이상, 다른 프로세스에 영향을 미치지 않는다. 그러나 스레드는 다른 스레드와 자원을 공유하기 때문에 하나의 스레드에 문제가 생기는 경우 다른 스레드들도 영향을 받게 된다.

</details>

# 5. Cache에 대하여 설명해주세요.

<details>
  <summary>답변</summary>

Cache란 자주 사용하는 데이터나 값을 미리 복사하여 저장해두는 장소이다.

즉 어떠한 데이터 요청이 있을 때 DB나 API 요청 없이 데이터를 빠르게 가져오도록 할 수 있다.

cache에 저장되는 데이터들은 시간적으로 자주 참조되는 데이터(시간 지역성)이거나, 참조된 데이터와 공간적으로 가까운 데이터(공간 지역성)들이 저장되게 된다.

cache는 비용이 비싼 메모리이기 때문에 cache 용량을 늘리는 것보다 적은 양의 데이터를 어떻게 저장하는 효율을 높이는 것이 더 합리적이다.

</details>

# 6. 이벤트 루프에 대해 설명해주세요.

<details>
  <summary>답변</summary>

이벤트 루프란 콜 스택을 모니터하면서 태스크 큐에 처리할 작업이 있는지 확인하는 단일 스레드 루프이다.

동작 원리는

1. V8엔진에서 코드가 실행 되면 콜 스택에 쌓이게 된다.
2. 비동기 함수인 경우 Web API를 호출한다.
3. Web API는 비동기 함수의 콜백함수를 콜백 큐에 넣는다.
4. 콜 스택이 비어있는 경우 콜백 큐에 담긴 콜백함수를 콜 스택으로 옮겨 실행하게 된다.

이러한 방식으로 단일 스레드 기반이지만 멀티 스레드인 것처럼 동작할 수 있다.

※ Web API는 JS 엔진 밖에 있는 브라우저가 지원하는 API이다.

</details>

# 7. setState 함수가 동기적으로 작동하나요? 비동기적으로 작동하나요?

<details>
  <summary>답변</summary>

setState 함수는 비동기적으로 작동한다. React는 state, props가 바뀔 때마다 리렌더링 된다. setState 함수가 동기적으로 작동하는 경우 연속적으로 setState 함수가 실행되는 코드가 있을 때 계속해서 리렌더링 되게 될 것이다. 이는 비효율적이고 성능에도 안 좋은 영향을 미치게 됩니다. 그렇기 때문에 React는 비동기 함수를 처리하는 콜백 큐가 비워지고 나서 리렌더링 하도록 설계되었다.

</details>

# 8. Promise.all(), Promise.race(), Promise.allSettled() 각각에 대하여 설명해주세요.

<details>
  <summary>답변</summary>

1. Promise.all()
   프로미스 배열을 인자로 가지며, 각각의 프로미스를 병렬적으로 처리하여 새로운 프로미스를 반환한다. 모든 프로미스가 fulfilled 되어야 결과를 돌려준다. 중간에 reject되는 프로미스가 있다면 에러를 발생시킨다. 병렬적으로 실행되지만 순서를 보장하기 때문에 첫번째 프로미스가 제일 나중에 fulfilled 되더라도 순서대로 resolve된 결과를 돌려준다.
2. Promise.race()
   Promise.all()과 마찬가지로 프로미스로 이루어진 이터러블을 인자로 받으며, 가장 먼저 fulfilled된 프로미스의 결과를 resolve하는 프로미스를 반환한다.
3. Promise.allSettled()
   마찬가지로 프로미스로 이루어진 이터러블을 인자로 받으며, 프로미스가 모두 settled 상태가 되면 결과를 배열로 반환한다.

</details>

# 9. async/await 과 promise의 차이

<details>
  <summary>답변</summary>

async/await 는 프로미스를 기반으로 동작하며 then이나 catch, finally와 같은 후속 처리 없이 동기처럼 프로미스를 사용할 수 있다.

에러 핸들링 측면에서 프로미스는 catch를 사용하여 에러를 캐치할 수 있고, async/await 는 try/catch문을 이용하여 에러를 캐치할 수 있다.

코드 가독성 측면에서 프로미스는 then을 많이 사용하게 되는 경우 가독성을 해칠 가능성이 있다. 그러나 async/await는 then과 같은 후속 처리 메소드를 사용하지 않아도 되므로 흐름을 파악하기 쉬운 코드를 작성할 수 있다.

</details>
