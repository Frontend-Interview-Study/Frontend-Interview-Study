# 1. Javascript의 Callback에 대해서 설명하고 여기서 발생할 수 있는 문제점과 이를 해결하기 위한 방법에 대해서 설명해주세요.

#### 콜백 함수란

콜백 함수(Callback Function)은 다른 코드의 인자로 넘겨주는 함수를 말한다. 콜백 함수를 넘겨받은 코드는 이 콜백 함수를 필요에 따라 적절한 시점에 실행한다.

콜백함수는 **제어권**과 관련이 깊다. 

어떤 함수 X를 호출하면서 '특정 조건일 때 함수 Y를 실행해서 나에게 알려달라'는 요청을 함께 보내는 것이다. 이 요청을 받은 함수 X의 입장에서는 해당 조건이 갖춰졌는지 여부를 스스로 판단하고 Y를 직접 호출한다.

이처럼 콜백 함수는 다른 코드(함수 또는 메서드)에게 인자를 넘겨줌으로써 그 제어권도 함께 위임한 함수다. 콜백 함수를 위임받은 코드는 자체적인 내부 로직에 의해 이 콜백 함수를 적절한 시점에 실행할 것이다.

#### 콜백 함수에서 발생할 수 있는 문제점

콜백 함수를 사용했을 때 발생할 수 있는 문제는 비동기적으로 사용되는 콜백 패턴에서 나타날 수 있는데 이를 콜백 지옥이라고 한다.

콜백 지옥은 콜백 함수를 익명 함수로 전달하는 과정에서 또 다시 콜백 안에 함수 호출이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상을 말한다.

이러한 콜백 지옥은 주로 이벤트 처리나 서버 통신과 같은 비동기 작업을 제어하기 위해서 사용되는데 이러한 프로그래밍은 가독성이 떨어지고 코드 수정을 어렵게한다.

#### 해결 방법

이러한 콜백 지옥은 Promise객체와 then 체인을 통해 해결할 수 있으며 `async/await` 를 통해 마치 동기적으로 비동기 처리를 할 수도 있다.



# 2. Javascript에서의 깊은 복사와 얕은 복사에 대해서 설명해주세요.

- 깊은 복사는 객체의 실제 값들을 복사하는 것이고 얕은 복사는 객체의 참조값(주소값)을 복사하는 것이다.

- 자바스크립트의 데이터타입은 원시값과 참조값이 있는데 원시값의 경우 복사를 하게 되면 값을 복사하는 것이기 때문에 깊은 복사가 이루어진다.

- 반면, 참조값의 경우 복사를 하게 되면 객체를 저장하고 있는 변수가 가리키는 객체의 주소값을 복사하는 것이기 때문에 얕은 복사가 이루어진다.



# 3. Var 키워드를 사용했을 때의 문제점에 대해서 설명해주세요.

- var 키워드는 기본적으로 변수의 중복 선언이 가능합니다. 이는 동일한 이름의 변수가 있다면 의도치 않게 먼저 선언된 변수의 값이 변하는 사이드 이펙트가 발생할 수 있는 문제가 있다.
- var 키워드는 함수 레벨 스코프를 사용한다. 이는 함수를 감싸는 코드 블록만 지역 스코프로 인정하는 것이고 다시 말해, `for` 나 `if` 블록 내부에서 var로 값을 선언한다면 전역 변수가 된다.
- var 키워드는 변수의 호이스팅이 발생한다. 호이스팅은 변수가 선언되기 전에 값에 접근할 수 있는 것을 말하는데 이때의 값은 `undefined` 로 초기화된다. 이처럼 호이스팅은 오류를 발생시키지는 않지만 가독성을 떨어뜨리고 프로그램의 흐름에 맞지 않기 때문에 문제가 발생할 수 있다.

# 4. Ajax에 대해서 설명하고 전통적인 방식과의 차이점에 대해서 설명주세요.

#### Ajax란

AJax란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다. AJax는 브라우저에서 제공하는 Web API인 `XMLHttpRequest` 객체를 기반으로 동작한다. `XMLHttpRequest` 는 HTTP 비동기 통신을 위한 메서드와 프로퍼티를 제공한다.

이전의 웹페이지는 `html` 태그로 시작해서 `html` 태그로 끝나느 완전한 HTML을 서버로부터 전송받아 웹페이지 전체를 처음부터 다시 렌더링하는 방식으로 동작했다. 따라서 화면이 전환되면 서버로부터 새로운 HTML을 전송받아 웹페이지 전체를 처음부터 다시 렌더링한다.

#### 전통적인 방식의 단점

이런 전통적인 방식은 다음과 같은 단점이 있다.

1. 이전 웹페이지와 차이가 없어서 변경할 필요가 없는 부분까지 포함된 완전한 HTML을 서버로부터 매번 다시 전송받기 때문에 불필요한 데이터 통신이 발생한다.
2. 변경할 필요가 없는 부분까지 처음부터 다시 렌더링한다. 이로 인해 화면 전환이 일어나면 화면이 순간적으로 깜박이는 현상이 발생한다.
3. 클라이언트와 서버와의 통신이 동기 방식으로 동작하기 때문에 서버로부터 응답이 있을 때까지 다음 처리는 블로킹된다.

Ajax의 등작은 이전의 전통적인 패러다임을 획기적으로 전환했다. 즉, 서버로부터 웹페이지의 변경에 필요한 데이터만 비동기 방식으로 전송받아 웹페이지를 변경할 필요 없는 부분은 다시 렌더링하지 않고, **변경할 필요가 있는 부분만 한정적으로 렌더링하는 방식이 가능**해진 것이다. 이를 통해 브라우저에서도 데스크톱 애플리케이션과 유사한 빠른 퍼포먼스와 부드러운 화면 전환이 가능해졌다.

#### Ajax의 장점

Ajax는 전통적인 방식과 비교했을 때 다음과 같은 장점이 있다.

1. 변경할 부분을  갱신하는 데 필요한 데이터만 서버로부터 전송받기 때문에 불필요한 데이터 통신이 발생하지 않는다.
2. 변경할 필요가 없는 부분은 다시 렌더링하지 않는다. 따라서 화면이 순간적으로 깜박이는 현상이 발생하지 않는다.
3. 클라이언트와 서버와의 통신이 비동기 방식으로 동작하기 때문에 서버에게 요청을 보낸 이후 블로킹이 발생하지 않는다.



# 5. React Query에 대해서 알고 계신가요? 알고 계시면 React Query를 왜 사용하는지 설명해주세요.

1. React Query는 데이터 Fetching, 캐싱, 동기화, 서버 쪽 데이터 업데이트를 쉽게 만들어 줍니다.

2. 특히, 클라이언트의 데이터를 관리하는 것보다 서버 데이터를 관리하는 부분에서 React Query의 장점이 잘 드러납니다.

   > 예를 들어 두 명의 사용자가 있다고 했을 때, 한 명의 사용자가 글을 수정하게 되면 다른 사용자는 변경된 데이터를 바라볼 수 있어야 하고
   > 이는 곧 서버의 데이터와 관련이 있기 때문에 서버 데이터를 관리하는 데 더욱 적합하다고 할 수 있다.

3. React Hook과 구조가 비슷하기 때문에 `React`스러운 패키지입니다.

4. 캐싱을 통해 불필요한 서버 자원의 낭비를 줄일 수 있습니다.

   > 예를 들어,
   > `staleTime: Infinity`, `cacheTime: Infinity` 로 설정하게 되면 앱을 종료하기 전까지 다시는 `fetch`되지 않는 데이터로 만들 수 있습니다.

5. `isLoading`, `isError` 등 그동안의 클라이언트에서 관리해줘야 했던 상태값들이나 메소드를 제공하기 때문에 직접 조작할 필요가 없어집니다.

6. 클라이언트에서 관리해야하는 데이터가 줄어들기 때문에 클라이언트 상태관리를 더 쉽게 할 수 있다.

# 6. 웹사이트의 성능을 최적화할 수 있는 방법을 설명해주세요.

- style은 상단, js는 하단에서 불러오기
- 웹팩(`Webpack`) 사용
- js의 공백 줄이기
- html 작성시 불필요한 div를 제거
- css 최적화
  - 리플로우, 리페인트(Reflow/Repaint)를 고려한 스타일 작성
  - 사용하지 않는 css 제거
- 이미지 최적화
  - picture, img 지연로딩 활용하기
  - 스프라이트 이미지 사용
- 핵심적인 웹 지표(`LCP,FID,CLS`) 최적화
- 애니메이션은 js보다는 css로 사용
- 헤더에 만료기한 넣기
- SEO (검색엔진최적화)
- CDN 사용
- Gzip 사용
- 파일 개수 줄이기
- 라이브러리 의존도 낮추기

[참고](https://velog.io/@hsecode/%EC%B5%9C%EC%A0%81%ED%99%94-%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95-5%EB%B6%84-%EC%99%84%EC%84%B1)



# 7. 브라우저의 저장소 중 웹스토리지에 대해서 설명해주세요.

#### Web Storage

Web Storage의 개념은 키/값 쌍으로 데이터를 저장하고 키를 기반으로 데이터를 조회하는 패턴이다.
그리고 영구저장소(LocalStorage)와 임시저장소(SessionStorage)를 따로 두어 데이터의 지속성을 구분할 수 있어 응용 환경에 맞는 선택이 가능하다.

**Web Storage는 Cookie와 비슷하지만 아래와 같은 차이가 있다.**

- 쿠키는 매번 서버로 전송된다.

웹 사이트에서 쿠키를 설정하면 이후 모든 웹 요청은 쿠키정보를 포함하여 서버로 전송된다. Web Storage는 저장된 데이터가 클라이언트에 존재할 뿐 서버로 전송은 이루어지지 않는다. 이는 네트워크 트래픽 비용을 줄여 준다.

- 단순 문자열을 넘어(스크립트) 객체정보를 저장할 수 있다.

문자열 기반 데이터 이외에 체계적으로 구조화된 객체를 저장할 수 있다는 것은 개발 편의성을 제공해주는 주요한 장점이 된다. 브라우저의 지원 여부를 확인해 봐야 하는 항목이다.

- 용량의 제한이 없다

쿠키는 개수와 용량에 있어 제한이 있다. 하나의 사이트에서 저장할 수 있는 최대 쿠키 수는 20개이다. 그리고 하나의 사이트에서 저장할 수 있는 최대 쿠키 크기는 4KB로 제한되어 있다. 그러나 Web Storage에는 이러한 제한이 없다. 그러나 쿠키도 하위키를 이용하면 이러한 제한을 일부 해소할 수 있습니다. 그리고 대부분 쿠키의 제한으로까지 데이터를 저장할 일이 없다.

- 영구 데이터 저장이 가능하다

쿠키는 만료일자를 지정하게 되어 있어 언젠가 제거된다. 만료일자로 지정된 날짜에 쿠키는 제거되는 것이다. 만약 만료일자를 지정하지 않으면 세션 쿠키가 된다. 만일 영구 쿠키를 원한다면 만료일자를 굉장히 멀게 설정하여 해결할 수 있다.
WebStorage는 만료기간의 설정이 없다. 즉, 한번 저장한 데이터는 영구적으로 존재하는 것이다.

[참고](https://velog.io/@ejchaid/localstorage-sessionstorage-cookie%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90)



# 8. GET과 POST에 대해서 설명하고 둘의 차이에 대해서 설명해주세요.

#### GET

 GET 은 클라이언트에서 서버로 어떠한 리소스로 부터 정보를 요청하기 위해 사용되는 메서드이다. 

- GET 요청은 캐시가 가능하다. 
   : GET을 통해 서버에 리소스를 요청할 때 웹 캐시가 요청을 가로채 서버로부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환한다. HTTP 헤더에서 cache-control 헤더를 통해 캐시 옵션을 지정할 수 있다.

- GET 요청은 브라우저 히스토리에 남는다.

- GET 요청은 북마크 될 수 있다.

- GET 요청은 길이 제한이 있다.
   : GET 요청의 길이 제한은 표준이 따로 있는건 아니고 브라우저마다 제한이 다르다고 한다. 

- GET 요청은 중요한 정보를 다루면 안된다. ( 보안 )
   : GET 요청은 파라미터에 다 노출되어 버리기 때문에 최소한의 보안 의식이라 생각하자.

- GET은 데이터를 요청할때만 사용 된다.

#### POST

POST는 클라이언트에서 서버로 리소스를 생성하거나 업데이트하기 위해 데이터를 보낼 때 사용 되는 메서드다.

- POST 요청은 캐시되지 않는다.

- POST 요청은 브라우저 히스토리에 남지 않는다.

- POST 요청은 북마크 되지 않는다.
- POST 요청은 데이터 길이에 제한이 없다.



#### 차이

- **사용목적** : GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용한다.
DB로 따지면 GET은 SELECT 에 가깝고, POST는 Create 에 가깝다고 보면 된다.

- **요청에 body 유무** : GET 은 URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 HTTP 메시지에 body가 없다. POST 는 body 에 데이터를 담아 보내기 때문에 당연히 HTTP 메시지에 body가 존재한다.

[참고](https://noahlogs.tistory.com/35)



# 9. ES6의 제너레이터에 대해서 설명해주세요.

- ES6에서 도입된 제너레이터(Generator) 함수는 이터러블을 생성하는 함수이다. 제너레이터 함수를 사용하면 [이터레이션 프로토콜](https://poiemaweb.com/es6-iteration-for-of)을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현할 수 있다. 또한 제너레이터 함수는 비동기 처리에 유용하게 사용된다.

- 제너레이터 함수는 일반 함수와 같이 함수의 코드 블록을 한 번에 실행하지 않고 함수 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재시작할 수 있는 특수한 함수이다.
- 제너레이터 함수를 호출하면 제너레이터를 반환한다. 이 **제너레이터는 이터러블(iterable)이면서 동시에 이터레이터(iterator)인 객체이다.**

[참고](https://poiemaweb.com/es6-generator)

