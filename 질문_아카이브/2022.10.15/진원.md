# 1. 웹 성능 최적화를 위해 어떤 걸 고려하시나요?

크게 로딩 최적화, 렌더링 최적화 2가지 측면을 고려합니다.

우선 브라우저 기준의 로딩 최적화 방법들을 생각합니다.

우선 브라우저에서 HTML, CSS **파서가 DOM과 CSSOM을 생성한 뒤**, 생성된 객체들은 **트리구조로 연결**합니다. 그 후, 어태치먼트 DOM과 CSSOM을 결합하여 **렌더트리를 구축**합니다. 이후, Layout과정에서 브라우저 Viewport 내에서 생성된 렌더트리의 각 **노드들의 실제 위치와 크기를 계산**합니다. 그후, Paint 단계에서 **렌더트리를 화면의 픽셀로 변환**시킵니다. 이 때 픽셀로 변환된 결과는 하나의 레이어가 아니라 여러 개의 레이어로 관리합니다. 마지막으로, **Composite** 단계에서는 Paint 단계에서 생성된 레이어를 합성하여 실제 화면에 나타냅니다.

Html를 해석하는 과정에서 사이즈가 큰 파일을 렌더링 엔진이 만나게 되면 이를 로드하는 과정에서 화면이 멈춰 보이는 render-blocking 문제가 발생합니다.

이를 해결하기 위해선 대표적으로 자바스크립트 파일을 바디태그 하단에 위치시키거나, async, defer를 활용하여 파싱을 중단시키지 않거나, inline style을 사용하는 방법이 있습니다. async 속성은 HTML 파싱을 멈추지 않고 동시에 js 파일을 다운로드 하고 다운로드가 끝난 후에 자바스크립트를 실행합니다. defer 속성은 HTML 파싱을 멈추지 않고 동시에 js 파일을 다운로드하고 **HTML 파싱이 끝난 후**에 자바스크립트를 실행합니다. 일반적으로 async는 의존성이 없는 스크립트에, defer는 DOM제어와 관련이 있는 스크립트에 사용합니다. 인라인 스타일로 css를 선언하면 외부 파일을 로드하지 않기 때문에 로드하는 시간이 감소합니다.

브라우저 기준에서의 로딩 최적화 방법들

**하지만, 결국 의미 있는 콘텐츠가 유저에게 빨리 보여야 성능 개선이 의미가 있다고 생각**합니다. 브라우저 로딩 최적화 만으로는 이에 한계가 있다고 생각합니다. 즉, 사용자 기준의 로딩 최적화에 대해 고민해야 할 필요가 있습니다.

이에 대한 개선방안으로는 서버 사이드 렌더링이 있습니다. 브라우저가 html을 요청하는 시점에 바로 html을 생성해서 response로 보낸다면, 브라우저가 의미 있는 컨텐츠를 빠르게 로드 즉, 빠른 first meaningful paint를 할 수 있고, 유저에게 더 나은 사용자경험을 제공할 수 있다고 생각합니다.

또한, SSG로도 이를 해결할 수 있습니다. SSG는 **build Time때 페이지를 생성해두고 이 정적 html 파일을 생성하여 재활용하는 방식입니다. Next js에서도 이 방식을 권장하는 것으로 갈고 있습니다.** 페이지가 외부데이터에 의존적이어서 api요청을 통해 페이지 내부를 채우는 경우 etStaticProps를 사용하고, 페이지의path가 외부데이터에 의존적이어서 상품 클릭시 id값에 해당하는 요청을 보내 이에 대한 응답으로 페이지 내용을 채우는 경우 getStaticPaths + getStaticProps를 사용합니다.

차이점은 프리 렌더러를 사용한 SSG는 빌드 타임에, 서버 사이드 렌더링은 런타임에 html을 생성합니다.

이런 로딩 성능 최적화와 관련된 장점은 PWA에서도 찾아볼 수 있습니다. Block 리소스를 최적화하기 위해 critical rendering path에서 first meaningful path를 앞당기고, 초기 로딩에 불필요한것들은 lazy loading하여 성능을 개선시킵니다.

다음으로 렌더링 최적화 방법입니다.

첫 번째 방법은 **강제 동기 레이아웃이 발생할 때, 이를 줄이는 것**입니다. 돔 변경이 아니라 돔 프로퍼티를 읽기만 해도 이 과정이 생길 수 있습니다. 관련 코드를 한 번만 사용하도록 캐싱하여 이를 줄일 수 있습니다.

두 번째 방법은 **가상돔**을 사용하는 것입니다. 가상돔을 사용하여 바뀐 엘리먼트만 업데이트하여 돔 변경을 최소화하고, 불필요한 렌더링을 줄일 수 있습니다.

마지막 방법은 **웹 워커**를 사용하는 것입니다. 만약 메인 쓰레드에서 시간이 오래 걸리는 무거운 작업을 처리한다면, 렌더링 성능에 영향을 줍니다. 웹 워커를 사용해서 해당 작업을 워커 쓰레드에서 처리하게 한다면 메인 쓰레드는 짧은 프레임을 유지할 수 있고, 성능을 개선할 수 있습니다. 이를 사용하기 위해선, 웹펙에서 worker-loader를 사용하여 웹 워커를 사용할 수 있습니다.

부가적으로, 성능을 개선한 것은 아니지만, 이런 render-blocking이 발생했을 때, 유저에게 컨텐츠가 로딩되고 있다는 느낌을 주기 위해 스켈레톤 컴포넌트를 보여주는 것도 하나의 방법이라고 생각합니다.

# 2. setState 동작원리?

React에선 **setState는** 상태값 변경이 가능합니다. 이런 **setState는 비동기로 동작합니다.**

상태가 각각 바뀔 때마다 화면을 리렌더링 해야한다면 너무 많은 렌더링이 발생하는 문제가 생깁니다.

그래서 리액트는 이런 효율성 문제를 해결하기 위해 setState를 연속 호출하면 setState를 모두 **취합(batch)**한 후에 한 번에 렌더링하도록 합니다. state도 결국 객체이기 때문에, **같은 키값을 가진 경우라면 가장 마지막 실행값으로 덮어씌워집니다.** 그러면 여러번의 상태값 변화를 한 번의 렌더링으로 최신의 상태를 갱신할 수 있습니다.

# 3. 프로미스가 뭔가요?

자바스크립트 비동기 처리에 사용되는 객체입니다.

## 프로미스의 상태를 나타내는 것은 어떤 것이 있나요?

비동기 처리 로직이 아직 완료되지 않은 상태인 Pending, 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태인 Fulfilled, 비동기 처리가 실패하거나 오류가 발생한 상태인 Rejected 상태가 있습니다.

## 프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나요?

**Promise.resolve 메소드는** 인수로 전달한 **배열을 resolve(이행)**하는 Promise 객체를 반환합니다.

**Promise.reject 메소드는** 인수로 전달한 **배열을 reject(거부)**하는 Promise 객체를 반환합니다.

**Promise.all 메소드는 모든 프로미스가 이행하거나, 한 Promise가 거부될 때까지 대기**하는 Promise 객체를 반환합니다. 모든 Promise가 fulfilled 상태가 되면 **모든 처리 결과를 저장한 배열을 resolve**합니다. Promise가 **하나라도 rejected되면 즉시 에러 띄우고 종료됩니다.**

**Promise.allSettled 메소드는** **모든 Promise가 이행 또는 거부 될 때까지 대기**하는 Promise 객체를 반환합니다. 각각의 비동기 처리가 **settled된 상태들을 처리한 결과를 배열로 resolve합니다.**

**Promise.race 메소드는 모든 Promise 중 하나라도 처리될 때까지 대기**하는 프로미스를 반환합니다. **가장 먼저 fulfilled된 프로미스의 처리 결과만 resolve** 한 뒤 종료됩니다. 하나라도 reject되면 에러 띄우고 종료됩니다.

**Promise.any 메소드**는 주어진 모든 프로미스 중 **하나라도 이행하는 순간, 즉시 그 프로미스의 값으로 resolve하는 새로운 프로미스를 반환**합니다.

## async/await 가 뭔가요? 기존의 Promise와는 어떤 차이가 있죠? 

ES6에서 추가된 비동기 처리 문법으로 Promise를 체이닝하여 사용할 때의 단점을 보완하기 위해 사용됩니다.

비동기처리를 위한 함수 앞에 async 키워드를 붙인 뒤, 함수 내부에서 await 키워드를 사용해서 비동기처리를 합니다. await 은 Promise 가 완료될 때까지 기다리며,  resolve 한 값을 내놓습니다. 해당 Promise 에서 reject가 발생한다면 예외가 발생합니다.

Promise와는 다르게 **비동기적인 로직을 동기적으로 작성**할 수 있고, **try-catch를 통한 에러핸들링 및 보기 쉬운 분기처리** 등을 가능케하여 가독성을 높일 수 있다는 장점이 있습니다.

# 4. Redux와 Context API의 차이?

Props Drilling을 피하기 위해 전역적으로 상태를 관리려고 사용합니다. 전역 상태 관리 측면에서는 차이점이 큰 차이는 없습니다.

하지만, Context API를 사용하면 잦은 리렌더링문제가 발생합니다. 상태를 사용하는 컴포넌트 뿐 만 아니라 상태에 대한 액션을 사용하는 컴포넌트에서도 렌더링이 발생하기 때문입니다.

컨텍스트를 상태값과 액션으로 나눈다면 리렌더링 문제를 방지할 수 있습니다. 그런데 코드가 지저분해지고 길어지는 단점이 있습니다.

Redux를 사용하면 이를 방지할 수 있습니다.

또한, Redux는 Redux devtool extension를 활용하여 상태를 디버깅 할 수 있습니다.

# 5. MongoDB특징과 MySQL과의 차이점

MySQL은 관계형 데이터베이스 관리 시스템입니다. 반면에, MongoDB는 데이터를 JSON과 유사한 문서로 저장하는 NoSQL 데이터베이스입니다.

MySQL의 경직된 관계 구조는 애플리케이션에 오버헤드를 가중시키고 개발자가 코드의 객체를 관계 구조에 적응해야 하므로 개발자의 속도를 늦춥니다.

MongoDB를 사용하면 코드 내의 객체를 관계 테이블로 변환하는 복잡한 Object-Relational Mapping레이어가 제거됩니다. 또한 MongoDB 데이터베이스 스키마가 비즈니스 요건에 따라 유연하게 발전할 수 있습니다.
