# 1. 실행 컨텍스트에 대해 설명해주세요.

<details>

  <summary>답변</summary>

실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이다.
스코프, 호이스팅, this, 함수, 클로저 등의 동작원리를 담고 있다.

실행 컨텍스트는 `실행 컨텍스트 스택`과 `렉시컬 환경`으로 구성되어 있다.

- 실행 컨텍스트는 코드의 실행 순서를 LIFO(Last In First Out) 구조로 관리한다.
- 렉시컬 환경은 모든 식별자와 바인딩된 값, 스코프를 기록하고 관리한다.
- 렉시컬 환경은 식별자와 식별자에 대입된 값을 키-값 형태의 스코프(전역, 함수, 블록 스코프)로 생성하여 관리한다.

[실행 컨텍스트와 자바스크립트의 동작 원리](https://catsbi.oopy.io/fffa6930-ca30-4f7e-88b6-28011fde5867)

</details>

# 2. 태스크 큐와 마이크로 태스크 큐의 차이점?

<details>

  <summary>답변</summary>

콜백 큐에는 두 가지 종류가 있는데, 태스크 큐와 마이크로 태스크 큐가 있다. 태스크 큐는 매크로 태스크 큐라고도 한다.

- 태스크 큐는 `setTimeout`, `setInterval`, `setImmediate` 등의 함수가 들어간다.
- 마이크로 태스크 큐는 `Promise`, `process`, `queueMicroTask`와 같은 함수가 들어간다.

이벤트는 마이크로 태스크 큐의 태스크를 모두 처리한 후에 태스크 큐의 태스크를 처리한다. 따라서 Promise 콜백 함수가 setTimeout()의 콜백 함수보다 빨리 처리된다.

</details>

# 3. 이벤트 위임에 대하여 설명해주세요.

<details>

  <summary>답변</summary>

캡쳐링과 버블링을 활용한 방식으로, 각 엘리먼트마다 이벤트 핸들러를 할당하지 않고 공통되는 부모 엘리먼트에 이벤트 핸들러를 할당하여 이벤트를 관리하는 방식이다.

`이벤트 캡쳐링`은 상위 엘리먼트에서 이벤트가 발생한 타겟 엘리먼트까지 이벤트가 전달되어 내려오는 현상을 이야기하고, `이벤트 버블링`은 이벤트가 발생한 타겟 엘리먼트에서 그 엘리먼트의 조상들까지 이벤트가 전달되는 현상을 이야기 한다.

이벤트 위임을 이용하면 여러 개의 자식 엘리먼트에 대한 이벤트 관리를 효율적으로 할 수 있고, 자식 엘리먼트가 동적으로 추가되거나 삭제될 때 이벤트 핸들러가 제대로 삭제 되지 않아 발생할 수 있는 메모리 누수를 방지할 수 있다.

</details>

# 4. HTTP 상태 코드를 아는대로 말해주세요.

<details>

  <summary>답변</summary>

자주 쓰이는 상태 코드

| 상태코드 | 코드명                | 설명                                                                 |
| -------- | --------------------- | -------------------------------------------------------------------- |
| 200      | OK                    | 요청이 성공적으로 보내졌음                                           |
| 201      | Created               | 요청이 성공적이었으며 새로운 리소스가 생성됨                         |
| 400      | Bad Request           | 잘못된 문법으로 인해 서버가 요청을 이해할 수 없음                    |
| 401      | Unauthorized          | 비인증된 요청임                                                      |
| 403      | Forbidden             | 콘텐츠에 접근할 권리가 없음                                          |
| 404      | Not Found             | 요청받은 리소스를 찾을 수 없음                                       |
| 500      | Internal Server Error | 서버에 문제가 있지만 서버가 정확한 문제 상황에 대하여 설명할 수 없음 |

※ http status 401 vs 403?

- 401: 클라이언트가 인증되지 않음. 로그인을 하지 않은 상태로 결제 내역을 보려고 하는 경우
- 403: 접근 권한이 없음. 로그인을 하였지만 다른 사람의 결제 내역을 보려고 하는 경우

</details>

# 5. `<img>` 태그를 사용할 때 기본적으로 아래쪽에 공백이 생기게 되는데, 그 이유와 해결방법?

<details>

  <summary>답변</summary>

`<img>`태그는 inline 레벨 요소이기 때문에 기본적으로 일반 텍스트와 동일하게 baseline을 기준으로 정렬된다.
즉, `vertical-align: baseline;`이라는 뜻이다.

y, j, p, g, q 등과 같이 하강문자를 위해 아래쪽에 공간이 더 있어야 하기 때문에 기본적으로 공백이 생긴다.

이를 해결하기 위해서는

- `display: block;`: 한 줄을 다 차지한다는 단점이 있다.
- `line-height: 0;`: 컨테이너 안의 다른 텍스트들에도 영향이 가므로 좋은 방법은 아니다.
- `<img>`태그에 `vertical-align: middle / top / bottom;`: 정렬 기준을 바꾸는 방법으로 가장 좋은 방법이다.

</details>

# 6. 동일 출처 정책(Same Origin Policy)에 대하여 설명해주세요.

<details>

  <summary>답변</summary>

동일 출처 정책은 프로토콜, 포트, 호스트가 같은 origin으로만 리소스 상호작용을 주고 받을 수 있도록 한 정책이다.

예를 들어 `localhost:3000` 클라이언트에서 `localhost:8080` 서버로 ajax 요청을 보내면 위 정책에 따라 에러를 마주하게 된다.

이를 해결하기 위하여 등장한 것이 CORS(Cross-Origin Resource Sharing)이다.

## CORS?

추가 HTTP 헤더를 이용하여 출처가 다른 도메인에서의 ajax 요청이라도 서버 단에서 데이터 접근 권한을 허용하는 정책이다.

`Access-Control-Allow-Origin` response header를 이용하여 특정 도메인이나 전체 도메인에서의 접근을 허용할 수 있다.

또는 Express 미들웨어 cors를 이용하여 접근을 허용할 수 있다.

클라이언트 단에서는 프록시 서버를 이용하여 접근을 허용할 수 있다.

</details>

# 7. 자료구조에서의 배열과 자바스크립트 배열의 차이점?

<details>

  <summary>답변</summary>

자료구조에서의 배열은 동일한 크기를 가진 메모리 공간이 연속적으로 나열된 자료구조를 말한다.

그러나 자바스크립트에서의 배열은 동일한 크기를 갖지 않아도 되고 연속적으로 이어져 있지 않을 수도 있다.

배열의 요소가 연속적으로 이어져있지 않은 배열을 희소 배열이라 한다.

이처럼 자바스크립트의 배열은 엄밀히 말해 일반적인 의미의 배열이 아니며, 일반적인 배열의 동작을 흉내 낸 특수한 객체이다.

</details>

# 8. 웹 접근성과 웹 접근성에 맞는 마크업 예시를 들어보세요.

<details>

  <summary>답변</summary>

웹 접근성은 모든 사람이 차별없이 웹 사이트를 자유롭게 이용할 수 있게 하는 권리를 말한다.

- 이미지에 alt와 같은 속성을 이용하여 대체 텍스트 제공
- 동영상에 대본이나 자막을 제공하고 자동재생을 금지
- input 태그에 label 제공하기
- a 태그에 title 속성을 이용하여 설명 제공

등

</details>

# 9. useMemo와 useCallback의 차이점?

<details>

  <summary>답변</summary>

`useMemo`는 메모이제이션된 값을 반환하고, `useCallback`은 메모이제이션 된 함수를 반환한다.

※ 메모이제이션

- 프로그램 실행 시 이전에 연산된 값을 기억하고 있는 것
- 연산에 필요한 값이 변경되지 않았다면 이전에 연산된 값을 이용한다.

리액트는 props, state가 바뀔 때와 부모 컴포넌트가 리렌더링 될 때 컴포넌트가 리렌더링된다.
이 과정에서 불필요한 리렌더링이 발생할 수 있는데 이는 성능 저하의 원인이 되기 때문에 특정 상황에서만 리렌더링이 될 수 있도록 `useMemo`와 `useCallback`을 사용한다.

</details>
