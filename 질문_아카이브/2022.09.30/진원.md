# 1. 프로미스가 뭔가요?

자바스크립트 비동기 처리에 사용되는 객체입니다.

## 프로미스의 상태를 나타내는 것은 어떤 것이 있나요?

비동기 처리 로직이 아직 완료되지 않은 상태인 Pending, 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태인 Fulfilled, 비동기 처리가 실패하거나 오류가 발생한 상태인 Rejected 상태가 있습니다.

## 프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나요?

**Promise.resolve 메소드는** 인수로 전달한 **배열을 resolve(이행)**하는 Promise 객체를 반환합니다.

**Promise.reject 메소드는** 인수로 전달한 **배열을 reject(거부)**하는 Promise 객체를 반환합니다.

**Promise.all 메소드는 모든 프로미스가 이행하거나, 한 Promise가 거부될 때까지 대기**하는 Promise 객체를 반환합니다. 모든 Promise가 fulfilled 상태가 되면 **모든 처리 결과를 저장한 배열을 resolve**합니다. Promise가 **하나라도 rejected되면 즉시 에러 띄우고 종료됩니다.**

**Promise.allSettled 메소드는** **모든 Promise가 이행 또는 거부 될 때까지 대기**하는 Promise 객체를 반환합니다. 각각의 비동기 처리가 **settled된 상태들을 처리한 결과를 배열로 resolve합니다.**

**Promise.race 메소드는 모든 Promise 중 하나라도 처리될 때까지 대기**하는 프로미스를 반환합니다. **가장 먼저 fulfilled된 프로미스의 처리 결과만 resolve** 한 뒤 종료됩니다. 하나라도 reject되면 에러 띄우고 종료됩니다.

**Promise.any 메소드**는 주어진 모든 프로미스 중 **하나라도 이행하는 순간, 즉시 그 프로미스의 값으로 resolve하는 새로운 프로미스를 반환**합니다.

## async/await 가 뭔가요? 기존의 Promise와는 어떤 차이가 있죠? 

ES6에서 추가된 비동기 처리 문법으로 Promise를 체이닝하여 사용할 때의 단점을 보완하기 위해 사용됩니다.

비동기처리를 위한 함수 앞에 async 키워드를 붙인 뒤, 함수 내부에서 await 키워드를 사용해서 비동기처리를 합니다. await 은 Promise 가 완료될 때까지 기다리며,  resolve 한 값을 내놓습니다. 해당 Promise 에서 reject가 발생한다면 예외가 발생합니다.

Promise와는 다르게 **비동기적인 로직을 동기적으로 작성**할 수 있고, **try-catch를 통한 에러핸들링 및 보기 쉬운 분기처리** 등을 가능케하여 가독성을 높일 수 있다는 장점이 있습니다.

# 2. ES6에서 Arrow 함수를 언제 쓰나요? 왜 쓰나요?

Arrow 함수는 실제 개발시 **forEach함수의 콜백함수, 이벤트리스너, Object안의 함수**로 많이 사용됩니다.

**함수 본연의 기능인 입출력기능을 아주 잘 직관적으로 표현하는 문법입니다.**

파라미터가 하나라면 **소괄호를 생략**가능합니다. 또한, 중괄호 안에 return 한줄 뿐이라면 **중괄호와 return도 생략** 가능합니다.

이러한 특성 때문에 **함수의 입출력을 한눈에 확인하기 쉬워서 사용**합니다.

한 가지 유의할 점은, 일반적인 함수는 함수가 쓰인 위치에 따라서 내부의 this값이 변하는데, arrow 함수는은 어디서 쓰든간에 내부의 this 값은 **상위 스코프의 this를 가리킨다는 것입니다**.

# 3. 함수형 프로그래밍이란 무엇인가요? 어떤 특징이 있나요?

함수형 프로그래밍이란 거의 모든 것을 함수로 나누어 만들어 모듈화 수준을 높이는 프로그래밍 패러다임입니다.

함수형 프로그래밍에선 함수를 \***\*1급 객체\*\***로 간주합니다. 그리고, \***\*순수함수\*\***를 기반으로 코드를 작성해야 합니다. 또한, \***\*고차함수\*\***를 사용할 수 있습니다. 그리고, 작업시 데이터의 \***\*불변성\*\***을 보장해야 합니다. 마지막으로, 루프 문법을 사용하는 대신 **재귀**적으로 코드를 작성합니다.

## 앞서 말한 각 특징에 대해 좀 더 자세하게 설명해주실수 있나요?

**순수함수**란 함수가 어떤 일을 하기 위해 그것의 매개 변수 밖의 변수에 의존하거나 그것을 수정하는 부수효과(side-effect)가 없는 함수입니다.

이 함수는 동일한 입력에는 항상 같은 값을 반환하고, 함수의 실행이 프로그램의 실행에 영향을 미치지 않습니다.

**1급 객체는** 변수나 데이터 구조안에 담길 수 있습니다. 또한, 파라미터로 전달 될 수 있고, 반환값으로 사용될 수 있습니다. **자바스크립트의 함수**는 위 3가지 기준을 충족하기 때문에 **1급 객체로 간주됩니다**.

**고차함수란** 함수를 인자로써 전달 할 수 있고, 함수의 반환 값으로 또 다른 함수를 사용 할 수 있는 함수를 말합니다.

**불변성**은 함수 외부에서 데이터를 수정하지 않고 작업을 해야 한다는 특징입니다. 데이터의 변경이 필요한 경우, 원본 데이터 구조를 변경하지 않고 그 데이터의 복사본을 만들어서 그 일부를 변경하고, 변경한 복사본을 사용해 작업을 해야 합니다.

## 함수형 프로그래밍의 장단점은 뭔가요?

우선, 어떤 상태도 바꾸지 않고 주어진 입력에만 의존하기 때문에 **이해하기 쉽습니다.**

또한, 함수를 값으로 취급하고 이를 함수에 매개 변수로 전달할 수 있기 때문에 코드의 **가독성이 향상**됩니다.

하지만, 루프를 사용하는 대신 **재귀적으로 코딩하기 때문에 성능이 저하**될 수도 있습니다.

# 4. RESTful API에 대해서 설명해 주세요.

웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 **웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일인 REST를 기반으로 구현한 API**입니다.

**자원, 행위, 표현** 각 구성요소들의 역할을 잘 분리시켜야 합니다. HTTP URI를 통해 어떤 자원인지 명시하고, HTTP Method를 통해 해당 자원을 처리하기 위한 행위를 명시해야 합니다.

또한 **특정 언어나 기술에 종속되지 않고,** URI로 지정한 Resource에 대한 조작을 통일되고 한정적인 인터페이스로 수행해야 한다는 **유니폼 인터페이스** 특성, **작업을 위한 상태 정보를 따로 저장하고 관리하지 않는다**는 **무상태성, REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조 특성** 등을 만족해야 합니다**.**

# 5. Map & Set에 대해서 설명해주세요.

Map객체는 key와 value로 이루어진 컬렉션입니다.
기존의 객체와 다른점은 key값으로 문자열뿐만 아니라 객체 등 어떠한 타입을 가질 수 있습니다. 그리고 동일한 key를 포함시킬수 없기 때문에 key값이 유일합니다.
그뿐만 아니라 iterable하기 때문에 for ...of문, spread 등등 ES6의 문법들을 활용할 수 있습니다.

Set 객체는 value로 이루어진 컬렉션입니다.
중복이 없는 value을 저장할 때 쓰이기 때문에 value값이 유일하며 iterable하여 ES6의 일부 문법들을 활용할 수 있습니다.

# 6. CSR과 SSR의 차이점은 무엇인가요?

CSR은 최초 요청시에 HTML을 비롯해 CSS, Javascript 등 각종 리소스를 받아온 뒤, 렌더시 **서버에 데이터만 요청하고, 자바스크립트로 뷰를 컨트롤 하는 방식**이다.

SSR은 새로운 페이지가 렌더가 되야할 때, **서버에 새로운 페이지에 대한 요청**을 하는 방식입니다.

## SPA와 MPA의 차이점은 무엇인가요?

SPA는 서버로부터 **처음에만 페이지를 받아오고** 이후에는 **동적으로 페이지를 구성해서 새로운 페이지를 받아오지 않는** 웹 애플리케이션을 뜻합니다.

MPA는 서버로부터 **완전한 페이지를 받아오고** 이후에 데이터를 수정하거나 조회할 때, **다른 완전한 페이지로 이동하는** 웹 애플리케이션을 뜻한다.

## 그렇다면 SPA는 CSR인가요?

**아닙니다.**

**동적으로 페이지를 구성하여 렌더링 되는 화면이 바뀌게 한다**. 부분이 **CSR의 특징에** 해당되는 부분입니다.

SPA는 처음에만 페이지를 받아오고 이후에는 받아오지 않는데 이럼에도 데이터가 수정되고 조회되게 하고 싶어서 **CSR이란 방식을 채택한 것**입니다.

**SPA와 MPA**는 **페이지를 여러 개 쓰냐 한 개만 쓰냐의 차이**이고 **CSR과 SSR**은 **렌더링을 어디서 하냐의 차이**입니다.

## SPA를 SSR로 구현할 수는 없나요?

Next.js나 Nuxt.js와 같이 React, Vue 기반 SSR 프레임워크를 이용해서 구현할 수 있습니다.

## Next js의 동작원리를 간단하게 설명해주실수 있나요?

초기에 사용자가 Server에 페이지 접속을 요청하면, SSR방식으로 렌더링 될 HTML을 보냅니다. 즉, 각 페이지에 대해 미리 HTML를 생성합니다. 그 후, 브라우저에서 JavaScript를 다운로드하고 React를 실행합니다. 다른 페이지로 이동할 땐, CSR방식으로 브라우저에서 처리됩니다.

# 7. Virtual DOM이 무엇인지, 그리고 작동 원리에 대해 설명해주세요.

Virtual DOM은 UI 가상 표현을 메모리상에 두고 재조정 과정을 통해 실제 DOM과 동기화하는 것을 말합니다.

UI가 변경되면 전체 UI를 Virtual DOM으로 렌더링합니다. 그 후, 현재 Virtual DOM과 이전 Virtual DOM을 비교해 차이를 계산한 뒤, 변경된 부분을 실제 DOM에 반영하는 방식으로 재조정이 진행됩니다.

Virtual DOM에서 사용하는 "비교" 과정은 실제 DOM의 작업량을 실질적으로 줄여줍니다. 이러한 이유로 성능 향상에 도움이 됩니다.

# 8. 라이브러리와 프레임워크의 차이점?

프레임워크는 원하는 기능 구현에 집중하여 개발할 수 있도록 일정한 형태와 필요한 기능을 갖추고 있는 뼈대를 의미합니다.
라이브러리는 소프트웨어를 개발할 때 컴퓨터 프로그램이 사용하는 자원의 모임입니다. 즉 특정 기능을 모아둔 코드, 함수들의 집합이며 코드 작성 시 활용 가능한 도구들의 의미합니다.
프레임워크와 라이브러리의 차이점은 제어 흐름의 권한이 어디에 있는가 입니다.

**라이브러리를 사용할 때 사용자는 애플리케이션 코드의 흐름을 직접 제어해야합니다.** **개발 시 필요한 기능이 있을 경우 능동적으로 라이브러리를 호출하여 사용하거나 기존에 구성된 함수나 코드를 가져다 써야 합니다.**

**반면 프레임워크는 애플리케이션의 코드가 프레임워크에 의해 사용됩니다. 애플리케이션 코드는 프레임워크가 짜 놓은 틀에서 수동적으로 동작하기 때문에 제어의 흐름은 프레임워크가 가지고 있고 사용자가 그 안에 필요한 코드를 작성하게 됩니다.**
