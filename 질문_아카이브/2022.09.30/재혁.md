# 1. Closure의 정의와 왜 사용하는지 그리고 활용해본 예시에 대해서 설명해주세요.

### 정의

- 클로저란 어떤 함수에서 선언한 변수를 참조하는 내부함수를 외부로 전달할 경우 함수의 실행 컨텍스트가 종료된 후에도 해당 변수가 사라지지 않는 현상이다.

### 사용 이유

- 정보 은닉
- 접근 권한 제어
- 전역 변수를 대체하여 클로저를 활용할 수 있으므로 전역 변수의 남용을 줄일 수 있다.



# 2. 호이스팅에 대해서 설명해주세요.

- 자바스크립트 엔진은 코드를 평가하는 과정에서 변수 또는 함수의 선언부를 최상단으로 끌어올려 `undefined` 로 초기화를 진행하게 된다.
- 이에 따라 변수 또는 함수에 값이 할당 되기 이전에 해당 값에 접근한다면 `undefined` 값을 가지게 된다.



# 3. var, let, const의 차이에 대해서 설명해주세요.

### Var

- var 로 선언한 변수는 동일한 이름으로 여러 번 중복해서 선언이 가능함. 이와 같은 경우, 마지막에 할당된 값이 변수에 저장

- 이는 필요할 때마다 변수를 유연하게 사용할 수 있다는 장점이 될 수도 있지만, 기존에 선언해둔 변수의 존재를 잊고 값을 재할당하는 등의 실수가 발생할 가능성이 크다.
-  특히 코드량이 많아졌을 때, 같은 이름의 변수명이 여러 번 선언되었다면 어디 부분에서 문제가 발생하는지 파악하기 힘들뿐더러 값이 바뀔 우려가 있다.

### let

- var와 다르게 변수의 중복 선언이 불가능하다.
- 하지만 변수 초기화 이후 변수의 재할당은 가능하다.

### const

- let과 const의 차이는 값의 재할당이 가능한가이다.
- const는 값의 재할당이 불가능하다.



# 4. GET, POST와 같은 HTTP Method에 대해서 간단하게 설명해주세요

- GET: 서버로 부터 리소스를 취득
  - GET 메소드는 주로 데이터를 읽거나(Read) 검색(Retrieve)할 때에 사용되는 메소드이다. 만약에 GET요청이 성공적으로 이루어진다면 XML이나 JSON과 함께 200 (Ok) HTTP 응답 코드를 리턴한다. 에러가 발생하면 주로 404 (Not found) 에러나 400 (Bad request) 에러가 발생한다.
- POST: 서버에 리소스를 추가, 작성 등
  - POST 메소드는 주로 새로운 리소스를 생성(create)할 때 사용된다. 조금 더 구체적으로 POST는 하위 리소스(부모 리소스의 하위 리소스)들을 생성하는데 사용된다. 성공적으로 creation을 완료하면 201 (Created) HTTP 응답을 반환한다.
- PUT: 서버의 리소스를 갱신, 작성 등
  - PUT는 리소스를 생성 / 업데이트하기 위해 서버로 데이터를 보내는 데 사용한다.
- DELETE: 서버의 리소스를 삭제
  - DELETE 메서드는 지정된 리소스를 삭제합니다.
- PATCH: 리소스의 일부분을 수정
  - PATCH는 리소스를 생성 / 업데이트하기 위해 서버로 데이터를 보내는 데 사용한다. PUT은 데이터의 전부는 수정하지만 PATCH는 일부가 수정된다.



# 5. CSR vs SSR

**CSR**

한 번의 요청을 통해 HTML, CSS, Javascript 파일을 받아오고 사용자와의 상호작용에 따라 Javascript를 통해 동적으로 화면을 렌더링한다.

장점

- 서버에 단 한 번 요청을 하기 때문에 서버의 부하가 줄어들다.
- 사용자와의 상호 작용을 통해 동적으로 빠르게 화면을 렌더링 시키기 때문에 사용자 경험이 좋다.

단점

- 파일 크기가 커지게 되면 초기 로딩 시간이 길어질 수 있고 이는 곧 사용자 경험의 저하로 이어질 수 있다.
- 크롬을 제외한 다른 브라우저에서는 Javascript를 지원하지 않기 때문에 검색 엔진 봇이 크롤 하는 데에 문제가 있고 이로 인해 검색 엔진 최적화(SEO)에 어려움이 있다.

**SSR**

각각의 페이지 별로 서버에 요청을 해서 HTML, CSS, Javascript 파일을 받아와 화면을 렌더링한다.

장점

- 초기 로딩 속도가 빠르다
- JS를 통해 동적으로 화면을 렌더링 하는 것이 아니기 때문에 검색 엔진 최적화에 용이하다.

단점

- 페이지를 요청할 때마다 새로고침을 하기 때문에 사용자 경험이 좋지 않을 수 있다.
- 서버에 많은 요청을 하기 때문에 서버에 부담이 크다.



# 6. CSR의 문제점 중 하나인 큰 Bundle 사이즈를 줄이려면 어떻게 해야 되나요?

- default import 사용

  ```jsx
  import { time } from 'lodash' // 69.4kb (gzipped: 24.5kb)
  import times from 'lodash/times' // 2.8kb (gzipped: 1.2kb)
  ```

- Code Split : [참고](https://devowen.com/342)

- 크기가 큰 library 대체

[참고](https://roseline.oopy.io/dev/optimize-bundle-size)



# 7. Props와 State의 차이가 무엇인가요?

- props와 state 모두 일반 javascript 객체다. 
- props는 함수의 매개 변수처럼 컴포넌트에 전달되는 반면, state는 함수 안에 선언된 변수처럼 컴포넌트 내부에서 관리된다.



# 8. 클래스형 컴포넌트와 함수형 컴포넌트의 차이에 대해서 말씀해주세요.

### 1. 선언 방식

클래스형 컴포넌트는 선언하기 위해 아래와 같은 조건이 있다.

1. class 키워드 필요

2. Component로 상속을 받아야한다.

3. render() 메소드가 반드시 필요하다.



### 2. 일반적인 차이

**클래스형**

1. state, lifeCycle 관련 기능사용이 가능하다.

2. 함수형보다 메모리 자원을 더 사용한다.

3. 임의 메소드를 정의할 수 있다.

**함수형**

1. state, lifeCycle 관련 기능사용 불가능하다. [Hook을 통해 해결]

2. 클래스형보다 메모지 자원을 덜 사용한다.

3. 컴포넌트 선언이 편하다.



### 3. state 사용차이

**클래스형**

1. constructor 안에서 this.state 초기 값 설정 가능

2. constructor 없이 바로 state 초기값을 설정할 수 있다.

3. 클래스형 컴포넌트의 state는 **객체 형식**

4. this.setState 함수로 state의 값을 변경할 수 있다.

**함수형**

1. 함수형 컴포넌트에서는 useState 함수로 state를 사용한다.



### 4. props 사용 차이

**클래스형**

1. this.props로 통해 값을 불러올 수 있다.

2. 부모 객체의 키 값, 자식 props 활용

**함수형**

1. props를 불러올 필요 없이 바로 호출 할 수 있다.



### 5. LifeCycle

**클래스형**

`ComponentDidMount`, `ComponentDidUpdate` 등 라이프 사이클 메소드 사용 가능

**함수형**

Hook을 통해 라이프 사이클 메소드 사용 가능

[참고](https://velog.io/@sdc337dc/0.%ED%81%B4%EB%9E%98%EC%8A%A4%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8)



# 9. Git Flow에 대해서 알고 있으신가요? 안다면 사용하는 이유에 대해서 말씀해주세요.

### branch Naming

> `feature/{}`: 개발자가 특정 기능을 개발할 때 사용하는 브랜치입니다. `feature/{칸반티켓이름}` 형태로 브랜치를 만든 후, 티켓 기능을 구현합니다.
>
> `develop`: 개발 브랜치입니다. feature 브랜치가 완료되면 develop에 머지됩니다.
>
> `release`: 배포전에 머무는 브랜치입니다. release 브랜치의 코드를 바탕으로 QA팀에서 QA를 수행합니다.
>
> `master(혹은 main)`: 실제 서비스로 런칭될 코드가 런칭되는 브랜치입니다.
>
> `hotfix`: 긴급 패치가 필요할때 사용하는 브랜치입니다. hotfix에서 수정된 내용은 develop과 master에 동시에 머지됩니다.

### 사용 이유

1. **독립적인 개발 환경**

Gitflow 사용시 기능(티켓) 단위로 독립적인 Branch를 만들기 떄문에 다른사람의 개발 결과에 영향을 받지 않는 독립적인 개발환경을 만들어줍니다. 이는 최소한의 방해로 개발을 할 수 있게 도와줍니다.

2. **쉬운 추적**

Gitflow의 feature 브랜치는 칸반 보드의 티켓과 연동이 됩니다. 칸반 보드를 보고 어떤 기능이 통합되었는지 확인이 가능하며, 오류 발생시 어떤 기능을 개발하다가 문제가 생겼는지 확인하고 쉽게 `UNDO` 할 수 있습니다.

3. **배포 정책 및 CI/CD 연동**

Branch 별로 역할이 분리되어있기 때문에 각 Branch의 update에 맞춰 배포 & 테스트를 하기에 용이합니다.





